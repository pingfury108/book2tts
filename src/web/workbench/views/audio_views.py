import os
import time
import tempfile
from collections import defaultdict

from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.views.decorators.http import require_http_methods
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse, HttpResponse
from django.core.files.base import ContentFile
from django.conf import settings
from django.db import transaction
from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
from django.utils import timezone
from django.contrib import messages
from django.db.models import Q

from ..models import Books, AudioSegment, UserTask, DialogueScript, VoiceRole
from ..tasks import synthesize_audio_task, start_audio_synthesis_on_commit
from book2tts.tts import edge_tts_volices
from book2tts.edgetts import EdgeTTS
from book2tts.audio_utils import get_audio_duration, estimate_audio_duration_from_text
from home.models import UserQuota, OperationRecord
from book2tts.multi_voice_tts import MultiVoiceTTS


def get_or_create_dialogue_virtual_book(user):
    """Ëé∑ÂèñÊàñÂàõÂª∫ÂØπËØùËÑöÊú¨ËôöÊãü‰π¶Á±ç"""
    virtual_book_name = "üì¢ ÂØπËØùËÑöÊú¨ÈõÜ"
    virtual_book, created = Books.objects.get_or_create(
        user=user,
        name=virtual_book_name,
        defaults={
            'file_type': '.virtual',
            'file': None,  # ËôöÊãü‰π¶Á±çÊó†Êñá‰ª∂
        }
    )
    return virtual_book


def get_unified_audio_content(user=None, book=None, published_only=True):
    """
    Áªü‰∏ÄËé∑ÂèñÈü≥È¢ëÂÜÖÂÆπÔºàAudioSegment + DialogueScriptÔºâ
    ËøîÂõûÁªü‰∏ÄÊ†ºÂºèÁöÑÊï∞ÊçÆÂàóË°®ÔºåÊåâÂàõÂª∫Êó∂Èó¥ÂÄíÂ∫èÊéíÂàó
    """
    audio_items = []
    
    # ÊûÑÂª∫Êü•ËØ¢Êù°‰ª∂
    audio_filter = Q()
    dialogue_filter = Q()
    
    if user:
        audio_filter &= Q(user=user)
        dialogue_filter &= Q(user=user)
    
    if book:
        audio_filter &= Q(book=book)
        dialogue_filter &= Q(book=book)
    
    if published_only:
        audio_filter &= Q(published=True)
        dialogue_filter &= Q(published=True)
    
    # Ëé∑Âèñ‰º†ÁªüÈü≥È¢ëÁâáÊÆµ
    audio_segments = AudioSegment.objects.filter(audio_filter).order_by('-created_at')
    for segment in audio_segments:
        # Á°Æ‰øùAudioSegmentÊúâÊúâÊïàÁöÑbook
        if not segment.book or not segment.book.id:
            continue
            
        audio_items.append({
            'id': segment.id,
            'type': 'audio_segment',
            'title': segment.title,
            'text': segment.text,
            'book_page': segment.book_page,
            'file_url': segment.file.url if segment.file else None,
            'file_size': segment.file.size if segment.file else 0,
            'published': segment.published,
            'created_at': segment.created_at,
            'updated_at': segment.updated_at,
            'book': segment.book,
            'user': segment.user,
            # ‰∏∫‰∫ÜÂÖºÂÆπÊÄßÊ∑ªÂä†ÁöÑÂ≠óÊÆµ
            'file': segment.file,
            'subtitle_file': segment.subtitle_file,  # Ê∑ªÂä†Â≠óÂπïÊñá‰ª∂ÊîØÊåÅ
        })
    
    # Ëé∑ÂèñÂØπËØùËÑöÊú¨
    dialogue_scripts = DialogueScript.objects.filter(
        dialogue_filter & Q(audio_file__isnull=False)
    ).order_by('-created_at')
    
    # Â¶ÇÊûúÊúâÁî®Êà∑ÊåáÂÆö‰∏îÊúâÊó†ÂÖ≥ËÅî‰π¶Á±çÁöÑÂØπËØùËÑöÊú¨ÔºåÂàõÂª∫ËôöÊãü‰π¶Á±ç
    virtual_book = None
    if user and not book:  # Âè™ÊúâÂú®‰∏çÊåáÂÆöÁâπÂÆö‰π¶Á±çÊó∂ÊâçÈúÄË¶ÅËôöÊãü‰π¶Á±ç
        # Ê£ÄÊü•ÊòØÂê¶ÊúâÊó†ÂÖ≥ËÅî‰π¶Á±çÁöÑÂØπËØùËÑöÊú¨
        unlinked_scripts = dialogue_scripts.filter(book__isnull=True)
        if unlinked_scripts.exists():
            virtual_book = get_or_create_dialogue_virtual_book(user)
    
    for script in dialogue_scripts:
        # Á°ÆÂÆöÂΩíÂ±ûÁöÑ‰π¶Á±çÔºöÂ¶ÇÊûúÊ≤°ÊúâÂÖ≥ËÅî‰π¶Á±ç‰∏îÊúâËôöÊãü‰π¶Á±çÔºåÂàô‰ΩøÁî®ËôöÊãü‰π¶Á±ç
        target_book = script.book if script.book else virtual_book
        
        # Â¶ÇÊûú‰ªçÁÑ∂Ê≤°ÊúâbookÊàñbookÊó†ÊïàÔºåË∑≥ËøáËØ•ÂØπËØùËÑöÊú¨
        if not target_book or not target_book.id:
            continue
            
        audio_items.append({
            'id': script.id,
            'type': 'dialogue_script',
            'title': script.title,
            'text': f"üé≠ ÂØπËØùËÑöÊú¨ ({script.segment_count}ÊÆµ) - {', '.join(script.speakers[:3])}{'...' if len(script.speakers) > 3 else ''}",
            'original_text': script.original_text,  # Ê∑ªÂä†ÂéüÂßãÊñáÊú¨Â≠óÊÆµ
            'book_page': f"ÂØπËØùÈü≥È¢ë ({len(script.speakers)}‰∏™ËßíËâ≤)",
            'file_url': script.audio_file.url if script.audio_file else None,
            'file_size': script.audio_file.size if script.audio_file else 0,
            'published': script.published,
            'created_at': script.created_at,
            'updated_at': script.updated_at,
            'book': target_book,  # Á°Æ‰øùÊÄªÊòØÊúâÊúâÊïàÁöÑbookÂØπË±°
            'user': script.user,
            # ÂØπËØùËÑöÊú¨ÁâπÊúâÂ≠óÊÆµ
            'audio_duration': script.audio_duration,
            'speakers': script.speakers,
            'segment_count': script.segment_count,
            # ‰∏∫‰∫ÜÂÖºÂÆπÊÄßÊ∑ªÂä†ÁöÑÂ≠óÊÆµ
            'file': script.audio_file,
            'subtitle_file': script.subtitle_file,  # Ê∑ªÂä†Â≠óÂπïÊñá‰ª∂ÊîØÊåÅ
        })
    
    # ÊåâÂàõÂª∫Êó∂Èó¥ÂÄíÂ∫èÊéíÂàó
    audio_items.sort(key=lambda x: x['created_at'], reverse=True)
    
    return audio_items


def get_client_ip(request):
    """Ëé∑ÂèñÂÆ¢Êà∑Á´ØIPÂú∞ÂùÄ"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip


def get_user_agent(request):
    """Ëé∑ÂèñÁî®Êà∑‰ª£ÁêÜ"""
    return request.META.get('HTTP_USER_AGENT', '')


@login_required
def aggregated_audio_segments(request):
    """Display aggregated audio segments grouped by book, including dialogue audio"""
    
    # Get the current user's audio segments, ordered by created_at descending
    audio_segments = AudioSegment.objects.filter(user=request.user).order_by('-created_at')
    
    # Get published dialogue scripts
    dialogue_scripts = DialogueScript.objects.filter(
        user=request.user, 
        published=True, 
        audio_file__isnull=False
    ).order_by('-created_at')

    # Get or create virtual book for dialogue scripts without book association
    virtual_book = get_or_create_dialogue_virtual_book(request.user)

    # Aggregate by book
    aggregated_data = defaultdict(list)
    book_ids = {}  # Track book IDs for each book name
    
    # Add traditional audio segments
    for segment in audio_segments:
        book_data = {
            "id": segment.id,
            "type": "audio_segment",
            "title": segment.title,
            "text": segment.text,
            "book_page": segment.book_page,
            "file_url": segment.file.url,
            "published": segment.published,
            "created_at": segment.created_at
        }
        aggregated_data[segment.book.name].append(book_data)
        book_ids[segment.book.name] = segment.book.id  # Store book ID
    
    # Add dialogue audio - Áªü‰∏ÄÊï∞ÊçÆÊ†ºÂºèÔºåÁ°Æ‰øùÈÉΩÂÖ≥ËÅîÂà∞ÁúüÂÆûÁöÑBookÂØπË±°
    for script in dialogue_scripts:
        # Á°ÆÂÆöÂΩíÂ±ûÁöÑ‰π¶Á±ç
        target_book = script.book if script.book else virtual_book
        book_name = target_book.name
        
        # ËΩ¨Êç¢‰∏∫‰∏éAudioSegment‰∏ÄËá¥ÁöÑÊï∞ÊçÆÊ†ºÂºè
        book_data = {
            "id": script.id,
            "type": "dialogue_script",
            "title": script.title,
            "text": f"üé≠ ÂØπËØùËÑöÊú¨ ({script.segment_count}ÊÆµ) - {', '.join(script.speakers[:3])}{'...' if len(script.speakers) > 3 else ''}",
            "book_page": f"ÂØπËØùÈü≥È¢ë ({len(script.speakers)}‰∏™ËßíËâ≤)",
            "file_url": script.audio_file.url,
            "published": script.published,
            "created_at": script.created_at,
            # ‰øùÁïôÂØπËØùËÑöÊú¨ÁâπÊúâÁöÑÂ≠óÊÆµÔºå‰ΩÜ‰∏çÂΩ±ÂìçÈÄöÁî®Â§ÑÁêÜ
            "audio_duration": script.audio_duration,
            "speakers": script.speakers,
            "segment_count": script.segment_count,
            "subtitle_file": script.subtitle_file,  # Ê∑ªÂä†Â≠óÂπïÊñá‰ª∂ÊîØÊåÅ
        }
        aggregated_data[book_name].append(book_data)
        book_ids[book_name] = target_book.id  # ÂßãÁªàÂÖ≥ËÅîÁúüÂÆûÁöÑBook ID
        
    # Sort each book's segments by created_at descending
    for book_name in aggregated_data:
        aggregated_data[book_name].sort(key=lambda x: x['created_at'], reverse=True)
        
    # Prepare data structure with book IDs
    books_with_ids = {}
    for book_name, segments in aggregated_data.items():
        books_with_ids[book_name] = {
            "segments": segments,
            "book_id": book_ids[book_name]  # ÊâÄÊúâBook IDÈÉΩÊòØÁúüÂÆûÁöÑ
        }

    # Convert to standard dictionary and pass to template
    context = {
        "books_with_ids": books_with_ids,
        "aggregated_data": dict(aggregated_data)
    }
    return render(request, "aggregated_audio_segments.html", context)


@login_required
def get_voice_list(request):
    """Get available voices from edge_tts"""
    voices = edge_tts_volices()
    return render(request, "voice_list.html", {"voices": voices})


@login_required
def get_user_quota(request):
    """Get user points information"""
    user_quota, created = UserQuota.objects.get_or_create(user=request.user)
    
    # Get current points
    current_points = user_quota.points
    
    # Determine points status and color
    if current_points > 500:  # More than 500 points
        status_class = "text-success"
        status_icon = "‚úÖ"
    elif current_points > 100:  # More than 100 points
        status_class = "text-warning"
        status_icon = "‚ö†Ô∏è"
    else:  # Less than 100 points
        status_class = "text-error"
        status_icon = "‚ùå"
    
    context = {
        "user_quota": user_quota,
        "current_points": current_points,
        "status_class": status_class,
        "status_icon": status_icon,
    }
    
    return render(request, "quota_info.html", context)


@login_required
def get_points_rules(request):
    """Get points deduction rules for display"""
    try:
        from home.utils import PointsManager
        
        # Get all active points configurations
        all_configs = PointsManager.get_all_active_configs()
        
        # Define rule display information
        rule_info = {
            'audio_generation': {
                'name': 'Èü≥È¢ëÁîüÊàê',
                'icon': 'üéµ',
                'description': 'Â∞ÜÊñáÊú¨ËΩ¨Êç¢‰∏∫ËØ≠Èü≥'
            },
            'ocr_processing': {
                'name': 'OCRÂ§ÑÁêÜ',
                'icon': 'üìÑ',
                'description': 'ÂõæÁâáÊñáÂ≠óËØÜÂà´'
            }
        }
        
        # Build rules list
        rules = []
        for operation_type, config in all_configs.items():
            if operation_type in rule_info:
                rules.append({
                    'operation_type': operation_type,
                    'name': rule_info[operation_type]['name'],
                    'icon': rule_info[operation_type]['icon'],
                    'description': rule_info[operation_type]['description'],
                    'points_per_unit': config['points_per_unit'],
                    'unit_name': config['unit_name']
                })
        
        # Sort rules for consistent display
        rules.sort(key=lambda x: x['operation_type'])
        
        return JsonResponse({
            'status': 'success',
            'rules': rules
        })
        
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Ëé∑ÂèñÁßØÂàÜËßÑÂàôÂ§±Ë¥•: {str(e)}'
        }, status=500)


@login_required
@require_http_methods(["POST"])
def synthesize_audio(request):
    """‰ΩøÁî®ÂºÇÊ≠•‰ªªÂä°ÂêàÊàêÈü≥È¢ë"""
    # Ëé∑ÂèñËØ∑Ê±ÇÊï∞ÊçÆ
    text = request.POST.get("text")
    voice_name = request.POST.get("voice_name")
    book_id = request.POST.get("book_id")
    title = request.POST.get("title", "")
    book_page = request.POST.get("book_page", "")
    page_display_name = request.POST.get("page_display_name", "")
    audio_title = request.POST.get("audio_title", "")
    
    if not text or not voice_name or not book_id:
        return JsonResponse({"status": "error", "message": "Missing required parameters"}, status=400)
    
    # È™åËØÅ‰π¶Á±çÂ≠òÂú®
    book = get_object_or_404(Books, pk=book_id)
    
    # Ëé∑ÂèñÊàñÂàõÂª∫Áî®Êà∑ÈÖçÈ¢ù
    user_quota, created = UserQuota.objects.get_or_create(user=request.user)
    
    # ‰º∞ÁÆóÈü≥È¢ëÊó∂ÈïøÊù•ËøõË°åÂâçÁΩÆÊ£ÄÊü•
    estimated_duration_seconds = estimate_audio_duration_from_text(text)
    
    # È¢ÑÊ£ÄÊü•ÁßØÂàÜÔºàÊèêÂâçÂëäÁü•Áî®Êà∑ÁßØÂàÜ‰∏çË∂≥Ôºâ
    from home.utils import PointsManager
    required_points = PointsManager.get_audio_generation_points(estimated_duration_seconds)
    if not user_quota.can_consume_points(required_points):
        # ËÆ∞ÂΩïÈÖçÈ¢ù‰∏çË∂≥ÁöÑÊìç‰Ωú
        OperationRecord.objects.create(
            user=request.user,
            operation_type='audio_create',
            operation_object=f'{book.name} - {title or page_display_name}',
            operation_detail=f'Èü≥È¢ëÂêàÊàêÂ§±Ë¥•ÔºöÁßØÂàÜ‰∏çË∂≥„ÄÇÈ¢Ñ‰º∞ÈúÄË¶Å {required_points} ÁßØÂàÜÔºåÂâ©‰Ωô {user_quota.points} ÁßØÂàÜ',
            status='failed',
            metadata={
                'book_id': book_id,
                'book_name': book.name,
                'estimated_duration': estimated_duration_seconds,
                'required_points': required_points,
                'remaining_points': user_quota.points,
                'text_length': len(text),
                'voice_name': voice_name,
                'error_reason': 'insufficient_points'
            },
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        return JsonResponse({
            "status": "error", 
            "message": f"ÁßØÂàÜ‰∏çË∂≥„ÄÇÈ¢Ñ‰º∞ÈúÄË¶Å {required_points} ÁßØÂàÜÔºåÂâ©‰Ωô {user_quota.points} ÁßØÂàÜ"
        }, status=400)
    
    try:
        # ÂêØÂä®ÂºÇÊ≠•‰ªªÂä°
        task = synthesize_audio_task.delay(
            user_id=request.user.id,
            text=text,
            voice_name=voice_name,
            book_id=book_id,
            title=title,
            book_page=book_page,
            page_display_name=page_display_name,
            audio_title=audio_title,
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        
        # ÂàõÂª∫UserTaskËÆ∞ÂΩï
        user_task = UserTask.objects.create(
            user=request.user,
            task_id=task.id,
            task_type='audio_synthesis',
            book=book,
            title=audio_title or title or page_display_name,
            status='pending',
            metadata={
                'text': text,
                'voice_name': voice_name,
                'book_id': book_id,
                'title': title,
                'book_page': book_page,
                'page_display_name': page_display_name,
                'audio_title': audio_title,
                'estimated_duration': estimated_duration_seconds,
                'text_length': len(text),
                'ip_address': get_client_ip(request),
                'user_agent': get_user_agent(request)
            }
        )
        
        # ËøîÂõû‰ªªÂä°ID‰æõÂâçÁ´ØËΩÆËØ¢Áä∂ÊÄÅ
        return JsonResponse({
            "status": "started", 
            "message": "Èü≥È¢ëÂêàÊàê‰ªªÂä°Â∑≤ÂêØÂä®",
            "task_id": task.id
        })
    
    except Exception as e:
        # ËÆ∞ÂΩïÂêØÂä®‰ªªÂä°Â§±Ë¥•ÁöÑÊìç‰Ωú
        OperationRecord.objects.create(
            user=request.user,
            operation_type='audio_create',
            operation_object=f'{book.name} - {title or page_display_name}',
            operation_detail=f'ÂêØÂä®Èü≥È¢ëÂêàÊàê‰ªªÂä°Â§±Ë¥•Ôºö{str(e)}',
            status='failed',
            metadata={
                'book_id': book_id,
                'book_name': book.name,
                'estimated_duration': estimated_duration_seconds,
                'text_length': len(text),
                'voice_name': voice_name,
                'error_reason': 'task_start_failed',
                'exception_message': str(e)
            },
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        print(f"Error starting synthesize_audio task: {str(e)}")
        return JsonResponse({"status": "error", "message": f"ÂêØÂä®Èü≥È¢ëÂêàÊàê‰ªªÂä°Â§±Ë¥•Ôºö{str(e)}"}, status=500)


@login_required
@require_http_methods(["GET"])
def check_task_status(request, task_id):
    """Ê£ÄÊü•Celery‰ªªÂä°Áä∂ÊÄÅ"""
    from celery.result import AsyncResult
    
    try:
        # Ëé∑Âèñ‰ªªÂä°ÁªìÊûú
        task_result = AsyncResult(task_id)
        
        # Ëé∑ÂèñÂØπÂ∫îÁöÑUserTaskËÆ∞ÂΩï
        try:
            user_task = UserTask.objects.get(task_id=task_id, user=request.user)
        except UserTask.DoesNotExist:
            return JsonResponse({
                'status': 'error',
                'message': '‰ªªÂä°‰∏çÂ≠òÂú®ÊàñÊó†ÊùÉÈôêËÆøÈóÆ'
            }, status=404)
        
        if task_result.state == 'PENDING':
            # ‰ªªÂä°ËøòÂú®Á≠âÂæÖÊâßË°å
            user_task.status = 'pending'
            user_task.progress_message = '‰ªªÂä°Á≠âÂæÖÊâßË°å‰∏≠...'
            response = {
                'status': 'pending',
                'message': '‰ªªÂä°Á≠âÂæÖÊâßË°å‰∏≠...'
            }
        elif task_result.state == 'PROCESSING':
            # ‰ªªÂä°Ê≠£Âú®ÊâßË°å
            progress_msg = task_result.info.get('message', 'Ê≠£Âú®Â§ÑÁêÜ...')
            user_task.status = 'processing'
            user_task.progress_message = progress_msg
            response = {
                'status': 'processing',
                'message': progress_msg
            }
        elif task_result.state == 'SUCCESS':
            # ‰ªªÂä°ÊàêÂäüÂÆåÊàê
            result = task_result.info
            user_task.status = 'success'
            user_task.progress_message = result.get('message', 'Èü≥È¢ëÂêàÊàêÂÆåÊàê')
            user_task.result_data = result
            user_task.completed_at = timezone.now()
            response = {
                'status': 'success',
                'message': result.get('message', 'Èü≥È¢ëÂêàÊàêÂÆåÊàê'),
                'audio_url': result.get('audio_url'),
                'audio_id': result.get('audio_id'),
                'audio_duration': result.get('audio_duration'),
                'remaining_quota': result.get('remaining_quota')
            }
        elif task_result.state == 'FAILURE':
            # ‰ªªÂä°Â§±Ë¥•
            error_info = task_result.info
            if hasattr(error_info, 'get') and callable(getattr(error_info, 'get')):
                # error_info ÊòØÂ≠óÂÖ∏
                error_msg = error_info.get('message', 'Èü≥È¢ëÂêàÊàêÂ§±Ë¥•')
                error_detail = error_info.get('error', str(error_info))
            else:
                # error_info ÊòØÂºÇÂ∏∏ÂØπË±°ÊàñÂÖ∂‰ªñÁ±ªÂûã
                error_msg = 'Èü≥È¢ëÂêàÊàêÂ§±Ë¥•'
                error_detail = str(error_info) if error_info else 'Êú™Áü•ÈîôËØØ'
            
            user_task.status = 'failure'
            user_task.error_message = error_detail
            user_task.progress_message = error_msg
            user_task.completed_at = timezone.now()
            response = {
                'status': 'failure',
                'message': error_msg,
                'error': error_detail
            }
        else:
            # ÂÖ∂‰ªñÁä∂ÊÄÅ
            user_task.status = task_result.state.lower()
            user_task.progress_message = f'‰ªªÂä°Áä∂ÊÄÅÔºö{task_result.state}'
            response = {
                'status': task_result.state.lower(),
                'message': f'‰ªªÂä°Áä∂ÊÄÅÔºö{task_result.state}'
            }
        
        # ‰øùÂ≠òUserTaskÊõ¥Êñ∞
        user_task.save()
        
        return JsonResponse(response)
    
    except Exception as e:
        print(f"Error checking task status: {str(e)}")
        return JsonResponse({
            'status': 'error',
            'message': f'Ê£ÄÊü•‰ªªÂä°Áä∂ÊÄÅÂ§±Ë¥•Ôºö{str(e)}'
        }, status=500)


@login_required
@csrf_exempt
@require_http_methods(["DELETE"])
def delete_audio_segment(request, segment_id):
    """Delete an audio segment by its ID"""
    # Get the audio segment or return 404 if not found
    segment = get_object_or_404(AudioSegment, pk=segment_id)
    
    # Check if the user owns this audio segment
    if segment.user != request.user:
        # ËÆ∞ÂΩïÊùÉÈôê‰∏çË∂≥ÁöÑÊìç‰Ωú
        OperationRecord.objects.create(
            user=request.user,
            operation_type='audio_delete',
            operation_object=f'Èü≥È¢ëÁâáÊÆµID: {segment_id}',
            operation_detail=f'Âà†Èô§Èü≥È¢ëÁâáÊÆµÂ§±Ë¥•ÔºöÊùÉÈôê‰∏çË∂≥ÔºåÂ∞ùËØïÂà†Èô§‰∏çÂ±û‰∫éËá™Â∑±ÁöÑÈü≥È¢ëÁâáÊÆµ',
            status='failed',
            metadata={
                'segment_id': segment_id,
                'segment_owner': segment.user.username,
                'error_reason': 'permission_denied'
            },
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        return JsonResponse({"status": "error", "message": "You don't have permission to delete this audio segment"}, status=403)
    
    # ‰øùÂ≠òÂà†Èô§ÂâçÁöÑ‰ø°ÊÅØÁî®‰∫éËÆ∞ÂΩï
    segment_title = segment.title
    book_name = segment.book.name
    book_id = segment.book.id
    
    try:
        # Get the file path and calculate audio duration before deletion
        file_path = segment.file.path if segment.file else None
        
        # Get audio duration to return quota using utility function
        # Must do this BEFORE deleting the file
        audio_duration_seconds = get_audio_duration(file_path, segment.text)
        
        # Store book reference before deletion
        book = segment.book
        
        # ‰ΩøÁî®‰∫ãÂä°Á°Æ‰øùÊï∞ÊçÆ‰∏ÄËá¥ÊÄß
        with transaction.atomic():
            # Âà†Èô§Èü≥È¢ëÁâáÊÆµ
            segment.delete()
            
            # Âà†Èô§Êñá‰ª∂‰ªéÂ≠òÂÇ®‰∏≠
            if file_path and os.path.exists(file_path):
                os.remove(file_path)
            
            # ËøîËøòÁßØÂàÜÁªôÁî®Êà∑
            if audio_duration_seconds > 0:
                user_quota, created = UserQuota.objects.get_or_create(user=request.user)
                from home.utils import PointsManager
                returned_points = PointsManager.get_audio_generation_points(audio_duration_seconds)
                user_quota.add_points(returned_points)
                user_quota.save()
        
        # ËÆ∞ÂΩïÊàêÂäüÁöÑÂà†Èô§Êìç‰Ωú
        OperationRecord.objects.create(
            user=request.user,
            operation_type='audio_delete',
            operation_object=f'{book_name} - {segment_title}',
            operation_detail=f'ÊàêÂäüÂà†Èô§Èü≥È¢ëÁâáÊÆµÔºö{segment_title}ÔºåÊó∂Èïø {audio_duration_seconds} ÁßíÔºåËøîËøòÁßØÂàÜ {returned_points} ÂàÜ',
            status='success',
            metadata={
                'segment_id': segment_id,
                'book_id': book_id,
                'book_name': book_name,
                'segment_title': segment_title,
                'audio_duration': audio_duration_seconds,
                'returned_points': returned_points,
                'file_path': file_path
            },
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        
        # Ê£ÄÊü•ÊòØÂê¶ÊòØHTMXËØ∑Ê±Ç
        if request.headers.get('HX-Request') == 'true':
            # Ê£ÄÊü•ÊòØÂê¶ÊòØËØ•‰π¶Á±çÁöÑÊúÄÂêé‰∏Ä‰∏™Èü≥È¢ëÁâáÊÆµ
            remaining_segments = AudioSegment.objects.filter(book=book, user=request.user).count()
            
            if remaining_segments == 0:
                # Â¶ÇÊûúÊòØÊúÄÂêé‰∏Ä‰∏™ÁâáÊÆµÔºåËøîÂõûÁ©∫Áä∂ÊÄÅHTML
                empty_state_html = '''
                <div class="alert alert-info shadow-lg" data-segment-id="{segment_id}">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" class="stroke-current shrink-0 w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                    </svg>
                    <span>ËØ•‰π¶Á±ç‰∏ãÊ≤°Êúâ‰ªª‰ΩïÈü≥È¢ëÁâáÊÆµ„ÄÇ</span>
                </div>
                '''.format(segment_id=segment_id)
                return HttpResponse(empty_state_html)
            else:
                # Âê¶ÂàôËøîÂõûÁ©∫ÂÜÖÂÆπÔºåËÆ©ÂÖÉÁ¥†Ë¢´Âà†Èô§
                return HttpResponse(status=200)
        else:
            # ÂØπ‰∫éÈùûHTMXËØ∑Ê±ÇÔºåËøîÂõûJSONÂìçÂ∫î
            return JsonResponse({
                "status": "success", 
                "message": "Audio segment deleted successfully",
                "returned_quota": audio_duration_seconds
            })
    
    except Exception as e:
        # ËÆ∞ÂΩïÂà†Èô§Â§±Ë¥•ÁöÑÊìç‰Ωú
        OperationRecord.objects.create(
            user=request.user,
            operation_type='audio_delete',
            operation_object=f'{book_name} - {segment_title}',
            operation_detail=f'Âà†Èô§Èü≥È¢ëÁâáÊÆµÂºÇÂ∏∏Ôºö{str(e)}',
            status='failed',
            metadata={
                'segment_id': segment_id,
                'book_id': book_id,
                'book_name': book_name,
                'segment_title': segment_title,
                'error_reason': 'exception',
                'exception_message': str(e)
            },
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        print(f"Error in delete_audio_segment: {str(e)}")
        if request.headers.get('HX-Request') == 'true':
            # ÂØπ‰∫éHTMXËØ∑Ê±ÇÔºåËøîÂõûÈîôËØØÊ∂àÊÅØ
            return HttpResponse(f"Âà†Èô§Â§±Ë¥•: {str(e)}", status=500)
        else:
            # ÂØπ‰∫éÈùûHTMXËØ∑Ê±ÇÔºåËøîÂõûJSONÂìçÂ∫î
            return JsonResponse({"status": "error", "message": str(e)}, status=500)


@login_required
@csrf_exempt
@require_http_methods(["POST"])
def toggle_publish_audio_segment(request, segment_id):
    """Toggle the published state of an audio segment"""
    # Get the audio segment or return 404 if not found
    segment = get_object_or_404(AudioSegment, pk=segment_id)
    
    # Check if the user owns this audio segment
    if segment.user != request.user:
        return JsonResponse({
            "status": "error", 
            "message": "ÊÇ®Ê≤°ÊúâÊùÉÈôê‰øÆÊîπÊ≠§Èü≥È¢ëÁâáÊÆµ",
            "error_type": "permission_denied"
        }, status=403)
    
    try:
        # Store original state
        original_state = segment.published
        
        # Toggle the published state
        segment.published = not segment.published
        segment.save()
        
        # Record operation
        OperationRecord.objects.create(
            user=request.user,
            operation_type='audio_publish',
            operation_object=f'{segment.book.name} - {segment.title}',
            operation_detail=f'Èü≥È¢ëÁâáÊÆµ{"ÂèëÂ∏É" if segment.published else "ÂèñÊ∂àÂèëÂ∏É"}ÊàêÂäü',
            status='success',
            metadata={
                'segment_id': segment_id,
                'book_id': segment.book.id,
                'book_name': segment.book.name,
                'segment_title': segment.title,
                'original_state': original_state,
                'new_state': segment.published,
                'action': 'publish' if segment.published else 'unpublish'
            },
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        
        # Return JSON response with detailed information
        return JsonResponse({
            "status": "success", 
            "message": f"Èü≥È¢ëÁâáÊÆµÂ∑≤{'ÂèëÂ∏É' if segment.published else 'ÂèñÊ∂àÂèëÂ∏É'}",
            "published": segment.published,
            "segment_id": segment_id,
            "action": "publish" if segment.published else "unpublish",
            "button_text": "ÂèñÊ∂àÂèëÂ∏É" if segment.published else "ÂèëÂ∏É",
            "button_class": "btn-warning" if segment.published else "btn-success",
            "icon_type": "unpublish" if segment.published else "publish",
            "toast_type": "success"
        })
    
    except Exception as e:
        # Record failed operation
        OperationRecord.objects.create(
            user=request.user,
            operation_type='audio_publish',
            operation_object=f'{segment.book.name} - {segment.title}',
            operation_detail=f'Èü≥È¢ëÁâáÊÆµÂèëÂ∏ÉÁä∂ÊÄÅÂàáÊç¢Â§±Ë¥•Ôºö{str(e)}',
            status='failed',
            metadata={
                'segment_id': segment_id,
                'book_id': segment.book.id,
                'book_name': segment.book.name,
                'segment_title': segment.title,
                'error_reason': 'exception',
                'exception_message': str(e)
            },
            ip_address=get_client_ip(request),
            user_agent=get_user_agent(request)
        )
        
        print(f"Error in toggle_publish_audio_segment: {str(e)}")
        return JsonResponse({
            "status": "error", 
            "message": f"Êìç‰ΩúÂ§±Ë¥•: {str(e)}",
            "error_type": "operation_failed",
            "toast_type": "error"
        }, status=500)


@login_required
def task_queue(request):
    """ÊòæÁ§∫Áî®Êà∑ÁöÑ‰ªªÂä°ÈòüÂàóÂàóË°®"""
    # Ëé∑ÂèñÊü•ËØ¢ÂèÇÊï∞
    status_filter = request.GET.get('status', 'all')
    page = request.GET.get('page', 1)
    
    # Âü∫Á°ÄÊü•ËØ¢
    tasks = UserTask.objects.filter(user=request.user)
    
    # Áä∂ÊÄÅËøáÊª§
    if status_filter == 'processing':
        tasks = tasks.filter(status__in=['pending', 'processing'])
    elif status_filter == 'success':
        tasks = tasks.filter(status='success')
    elif status_filter == 'failure':
        tasks = tasks.filter(status='failure')
    
    # ÂàÜÈ°µ
    paginator = Paginator(tasks, 20)  # ÊØèÈ°µ20‰∏™‰ªªÂä°
    try:
        tasks_page = paginator.page(page)
    except:
        tasks_page = paginator.page(1)
    
    # ÁªüËÆ°‰ø°ÊÅØ
    stats = {
        'total': UserTask.objects.filter(user=request.user).count(),
        'processing': UserTask.objects.filter(user=request.user, status__in=['pending', 'processing']).count(),
        'success': UserTask.objects.filter(user=request.user, status='success').count(),
        'failure': UserTask.objects.filter(user=request.user, status='failure').count(),
    }
    
    context = {
        'tasks': tasks_page,
        'stats': stats,
        'current_status': status_filter,
        'page_obj': tasks_page,
    }
    
    return render(request, 'task_queue.html', context)


@login_required
@require_http_methods(["POST"])
def cancel_task(request, task_id):
    """ÂèñÊ∂àÁî®Êà∑ÁöÑ‰ªªÂä°"""
    try:
        # Ëé∑ÂèñÁî®Êà∑ÁöÑ‰ªªÂä°
        user_task = get_object_or_404(UserTask, task_id=task_id, user=request.user)
        
        # Âè™ËÉΩÂèñÊ∂àÊú™ÂÆåÊàêÁöÑ‰ªªÂä°
        if user_task.status in ['pending', 'processing']:
            from celery import current_app
            
            # ÂèñÊ∂àCelery‰ªªÂä°
            current_app.control.revoke(task_id, terminate=True)
            
            # Êõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅ
            user_task.status = 'revoked'
            user_task.progress_message = '‰ªªÂä°Â∑≤Ë¢´Áî®Êà∑ÂèñÊ∂à'
            user_task.completed_at = timezone.now()
            user_task.save()
            
            return JsonResponse({
                'status': 'success',
                'message': '‰ªªÂä°Â∑≤ÂèñÊ∂à'
            })
        else:
            return JsonResponse({
                'status': 'error',
                'message': 'Âè™ËÉΩÂèñÊ∂àËøõË°å‰∏≠ÁöÑ‰ªªÂä°'
            }, status=400)
            
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'ÂèñÊ∂à‰ªªÂä°Â§±Ë¥•Ôºö{str(e)}'
        }, status=500)


@login_required
@require_http_methods(["DELETE"])
def delete_task_record(request, task_id):
    """Âà†Èô§‰ªªÂä°ËÆ∞ÂΩïÔºà‰ªÖÂà†Èô§ËÆ∞ÂΩïÔºå‰∏çÂΩ±ÂìçÂÆûÈôÖ‰ªªÂä°Ôºâ"""
    try:
        # Ëé∑ÂèñÁî®Êà∑ÁöÑ‰ªªÂä°
        user_task = get_object_or_404(UserTask, task_id=task_id, user=request.user)
        
        # Âè™ËÉΩÂà†Èô§Â∑≤ÂÆåÊàêÊàñÂ∑≤ÂèñÊ∂àÁöÑ‰ªªÂä°ËÆ∞ÂΩï
        if user_task.is_finished:
            user_task.delete()
            
            return JsonResponse({
                'status': 'success',
                'message': '‰ªªÂä°ËÆ∞ÂΩïÂ∑≤Âà†Èô§'
            })
        else:
            return JsonResponse({
                'status': 'error',
                'message': 'Âè™ËÉΩÂà†Èô§Â∑≤ÂÆåÊàêÁöÑ‰ªªÂä°ËÆ∞ÂΩï'
            }, status=400)
            
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': f'Âà†Èô§‰ªªÂä°ËÆ∞ÂΩïÂ§±Ë¥•Ôºö{str(e)}'
        }, status=500) 