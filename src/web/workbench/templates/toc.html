{% load custom_filters %}
<!-- TOC navigation component - optimized for jQuery loading into #src-text with multi-select support -->
<div class="toc-container h-full flex flex-col">
  <!-- Fixed control bar at the top -->
  <div class="flex justify-between items-center p-2 border-b border-base-300 bg-base-100 flex-shrink-0">
    <div class="text-sm text-base-content/70">
      <span id="selection-count">选择 0 项</span>
    </div>
    <div class="flex gap-1">
      <button id="select-all-btn" class="btn btn-xs btn-ghost">全选</button>
      <button id="clear-selection-btn" class="btn btn-xs btn-ghost">清除</button>
      <button id="load-selected-btn" class="btn btn-xs btn-primary" disabled>加载选中</button>
    </div>
  </div>
  
  <!-- Scrollable TOC list -->
  <div class="flex-1 overflow-y-auto">
    <ul id="toc-list" class="menu menu-sm bg-base-100 rounded-box w-full flex flex-col single-column" style="column-count:1 !important; columns:1 !important; display:block !important;">
      {% for toc in tocs %}
      <li class="toc-node {% if toc.has_children %}collapsed{% else %}toc-leaf{% endif %}" data-level="{{ toc.level|default:0 }}" data-has-children="{{ toc.has_children|yesno:"true,false" }}" data-href="{{ toc.href }}">
        <div class="toc-item flex w-full flex-col gap-1 rounded-lg px-2 py-1 transition-colors duration-200 hover:bg-base-200"{% if request.GET.toc == toc.href %} data-initial-active="true"{% endif %}>
          <div class="toc-node-header flex w-full items-center gap-1">
            {% if toc.has_children %}
              <button class="toc-toggle btn btn-ghost btn-xs btn-square flex-shrink-0 w-5 h-5 min-h-5 p-0" type="button" aria-label="展开目录" data-action="toggle">
                <i class="fas fa-chevron-right toc-toggle-icon text-xs transition-transform duration-200"></i>
              </button>
            {% else %}
              <span class="w-5 h-5 flex-shrink-0 inline-flex items-center justify-center"></span>
            {% endif %}
            <input type="checkbox" class="toc-checkbox checkbox checkbox-sm flex-shrink-0" value="{{ toc.href }}" data-toc-href="{{ toc.href }}" />
            <a class="flex-1 toc-link text-base-content opacity-80 hover:opacity-100 transition-colors duration-200 min-w-0"
               data-text-url="{% url 'text_by_toc' book_id=book_id %}"
               data-toc-href="{{ toc.href }}"
               data-names="{{ toc.href|stringformat:"s" }}"
            >
              <span class="flex items-center gap-2 min-w-0">
                {% if toc.has_children %}
                  <i class="fas fa-folder-open text-primary text-xs flex-shrink-0"></i>
                {% else %}
                  <i class="fas fa-file-lines text-base-content/70 text-xs flex-shrink-0"></i>
                {% endif %}
                <span class="truncate">
                  {% if request.GET.toc == toc.href %}<span class="indicator-dot mr-1">•</span>{% endif %}
                  {{ toc.title }}
                </span>
              </span>
            </a>
          </div>
        </div>
        <ul class="toc-children hidden mt-1 space-y-0.5 border-l border-dashed border-base-300 ml-6"></ul>
      </li>
      {% endfor %}
    </ul>
  </div>
  
  <!-- Loading indicator -->
  <div class="loading-container fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 z-50 hidden">
    <div class="bg-base-200 rounded-lg shadow-lg p-2">
      <div class="loading loading-spinner loading-xs"></div>
    </div>
  </div>
</div>

<script>
$(document).ready(function() {
  let selectedTocItems = new Set();
  
  const openNodes = window._tocOpenNodes || new Set();
  window._tocOpenNodes = openNodes;

  const activeItemClasses = ['bg-base-200', 'ring-1', 'ring-base-300/70', 'shadow-inner', 'font-medium'];
  const levelPaddingClasses = ['pl-0', 'pl-0', 'pl-0', 'pl-0', 'pl-0'];

  function escapeSelector(value) {
    if (window.CSS && CSS.escape) {
      return CSS.escape(value);
    }
    return value.replace(/([ #.;?+<>~=!:^$\[\](){}|\\/])/g, '\\$1');
  }

  function expandNode(node, remember = true) {
    if (!node || node.dataset.hasChildren !== 'true') return;
    node.classList.add('expanded');
    node.classList.remove('collapsed');
    node.setAttribute('aria-expanded', 'true');
    const toggleButton = node.querySelector('[data-action="toggle"]');
    const icon = node.querySelector('.toc-toggle-icon');
    const children = node.querySelector('.toc-children');
    if (children) {
      children.classList.remove('hidden');
    }
    if (icon) {
      icon.classList.add('rotate-90');
    }
    if (toggleButton) {
      toggleButton.setAttribute('aria-label', '收起目录');
      toggleButton.classList.add('btn-active');
    }
    if (remember) {
      openNodes.add(node.dataset.href);
    }
  }

  function collapseNode(node, remember = true) {
    if (!node || node.dataset.hasChildren !== 'true') return;
    node.classList.remove('expanded');
    node.classList.add('collapsed');
    node.setAttribute('aria-expanded', 'false');
    const toggleButton = node.querySelector('[data-action="toggle"]');
    const icon = node.querySelector('.toc-toggle-icon');
    const children = node.querySelector('.toc-children');
    if (children) {
      children.classList.add('hidden');
    }
    if (icon) {
      icon.classList.remove('rotate-90');
    }
    if (toggleButton) {
      toggleButton.setAttribute('aria-label', '展开目录');
      toggleButton.classList.remove('btn-active');
    }
    if (remember) {
      openNodes.delete(node.dataset.href);
    }
  }

  function toggleNode(node) {
    if (!node || node.dataset.hasChildren !== 'true') return;
    if (node.classList.contains('expanded')) {
      collapseNode(node);
    } else {
      expandNode(node);
    }
  }

  function buildTocTree() {
    const tocList = document.getElementById('toc-list');
    if (!tocList) return;

    const nodes = Array.from(tocList.children);
    tocList.innerHTML = '';

    const stack = [{ level: -1, container: tocList }];

    nodes.forEach(node => {
      const level = parseInt(node.dataset.level || '0', 10);

      // 找到正确的父容器
      while (stack.length > 1 && level <= stack[stack.length - 1].level) {
        stack.pop();
      }

      const parentContainer = stack[stack.length - 1].container;
      parentContainer.appendChild(node);

      // 为当前节点添加正确的缩进
      const header = node.querySelector('.toc-node-header');
      if (header) {
        levelPaddingClasses.forEach(cls => header.classList.remove(cls));
        header.classList.add(levelPaddingClasses[Math.min(levelPaddingClasses.length - 1, level)]);
      }

      // 如果有子容器，将其作为下一级的容器
      const childContainer = node.querySelector('.toc-children');
      if (childContainer) {
        stack.push({ level, container: childContainer });
      }
    });

    // 初始化所有有子节点的节点为折叠状态
    tocList.querySelectorAll('.toc-node[data-has-children="true"]').forEach(node => {
      collapseNode(node, false);
    });

    // 恢复之前展开的节点状态
    const validHrefs = new Set(nodes.map(node => node.dataset.href));
    const staleHrefs = [];

    openNodes.forEach(href => {
      const selector = `.toc-node[data-href="${escapeSelector(href)}"]`;
      const node = tocList.querySelector(selector);
      if (node) {
        expandNode(node, false);
      } else if (!validHrefs.has(href)) {
        staleHrefs.push(href);
      }
    });

    staleHrefs.forEach(href => openNodes.delete(href));

    // 展开包含活动项的所有祖先节点
    const activeItem = tocList.querySelector('.toc-item[data-selected="true"], .toc-item[data-initial-active="true"]');
    if (activeItem) {
      let ancestor = activeItem.closest('.toc-node');
      while (ancestor) {
        expandNode(ancestor, false);
        ancestor = ancestor.parentElement ? ancestor.parentElement.closest('.toc-node') : null;
      }
    }
  }

  buildTocTree();

  // 处理初始激活节点（来自服务器渲染）
  const initialActiveItem = document.querySelector('.toc-item[data-initial-active="true"]');
  if (initialActiveItem) {
    const initialLink = initialActiveItem.querySelector('.toc-link');
    if (initialLink) {
      const href = initialLink.dataset.tocHref;
      if (href) {
        selectedTocItems.add(href);
      }
    }
  }

  updateSelectionUI();
  
  // Function to update selection count and button states
  function updateSelectionUI() {
    const count = selectedTocItems.size;
    $('#selection-count').text(`选择 ${count} 项`);
    $('#load-selected-btn').prop('disabled', count === 0);
    
    // Update checkbox states
    $('.toc-checkbox').each(function() {
      const href = $(this).data('toc-href');
      $(this).prop('checked', selectedTocItems.has(href));
    });

    // Highlight selected items
    document.querySelectorAll('.toc-item').forEach(item => {
      item.classList.remove(...activeItemClasses);
      item.removeAttribute('data-selected');
      const link = item.querySelector('.toc-link');
      if (link) {
        link.classList.remove('font-semibold', 'opacity-100');
        link.classList.add('opacity-80');
      }
    });

    document.querySelectorAll('.toc-link').forEach(link => {
      const href = link.dataset.tocHref;
      if (selectedTocItems.has(href)) {
        const item = link.closest('.toc-item');
        if (item) {
          item.classList.add(...activeItemClasses);
          item.setAttribute('data-selected', 'true');
        }
        link.classList.remove('opacity-80');
        link.classList.add('font-semibold', 'opacity-100');
      }
    });
  }
  
  // Function to scroll active element into view
  function scrollActiveIntoView() {
    const activeElement = $('.toc-item[data-selected="true"]');
    if (activeElement.length) {
      const container = $('.toc-container .flex-1'); // Updated selector to use the scrollable container
      if (container.prop('scrollHeight') > container.height()) {
        container.animate({
          scrollTop: activeElement.offset().top - container.offset().top + container.scrollTop() - (container.height() / 2) + (activeElement.outerHeight() / 2)
        }, 200);
      }
    }
  }
  
  // Function to get selected items in TOC display order
  function getSelectedItemsInOrder() {
    const sortedSelectedItems = [];
    $('.toc-link').each(function() {
      const href = $(this).data('toc-href');
      if (selectedTocItems.has(href)) {
        sortedSelectedItems.push(href);
      }
    });
    return sortedSelectedItems;
  }
  
  // Function to load selected TOC items
  function loadSelectedTocItems() {
    if (selectedTocItems.size === 0) return;

    updateSelectionUI();
    
    // Show loading indicator
    $('.loading-container').removeClass('hidden');
    
    // Get the URL from any toc link (they're all the same)
    const url = $('.toc-link:first').data('text-url');
    
    // 按照TOC在页面中的显示顺序排序，而不是选中的操作顺序
    const sortedSelectedItems = getSelectedItemsInOrder();
    const names = sortedSelectedItems.join(',');
    
    // Reset audio display if function exists
    if (typeof resetAudioDisplay === 'function') {
      resetAudioDisplay();
    }
    
    // Fetch the text content using POST
    $.ajax({
      url: url,
      type: 'POST',
      dataType: 'json',
      data: {
        'names': names,
        'csrfmiddlewaretoken': '{{ csrf_token }}'
      },
      success: function(response) {
        // Handle JSON response
        if (response.status === 'success') {
          // Update the textarea with the texts from JSON response
          $('#src-text').val(response.texts);
          
          // 如果使用了OCR，显示额外信息
          if (response.ocr_used) {
            showOCRResultInfo(response);
          }
          
          // Update page state (use first selected item's info based on TOC order)
          const sortedSelectedItems = getSelectedItemsInOrder();
          const firstSelectedHref = sortedSelectedItems[0]; // 使用排序后的第一个
          const firstSelectedLink = $(`.toc-link[data-toc-href="${firstSelectedHref}"]`);
          if (firstSelectedLink.length) {
            const tocTitleElement = firstSelectedLink.find('.truncate');
            const resolvedTitle = tocTitleElement.length 
              ? tocTitleElement.text().trim() 
              : firstSelectedLink.text().trim();
            window.currentPageName = resolvedTitle;
            window.currentPageId = firstSelectedHref;
            
            // 收集所有选中项的页码（仅对PDF有效），按TOC顺序排序
            let allSelectedPages = [];
            // 使用排序后的选中项确保页码也按正确顺序
            sortedSelectedItems.forEach(href => {
              if (typeof parsePdfPageIds === 'function') {
                const pageIds = parsePdfPageIds(href);
                allSelectedPages.push(...pageIds);
              }
            });
            
            // Update current page state for image viewing
           if (typeof window.updateCurrentPageState === 'function') {
             window.updateCurrentPageState(
                window.currentPageId, 
                window.currentPageName, 
                null, // 不改变PDF类型
                allSelectedPages, // 传递所有页码
                sortedSelectedItems
              );
            }
            
            // Update audio title placeholder with count info
            const titleInput = document.getElementById('audio-title-input');
            if (titleInput) {
              if (selectedTocItems.size === 1) {
                titleInput.placeholder = `音频标题 (默认: ${window.currentPageName})`;
              } else {
                titleInput.placeholder = `音频标题 (默认: ${window.currentPageName} 等${selectedTocItems.size}章)`;
              }
            }
          }
          
          // Log state change
          if (typeof logState === 'function') {
            logState(`Content loaded with jQuery - ${selectedTocItems.size} items selected`);
          }
        } else {
          console.error('Error in response:', response);
          const errorMessage = '加载内容失败：' + (response.message || '未知错误');
          if (typeof showToast === 'function') {
            showToast(errorMessage, 'error');
          } else {
            showSimpleToast(errorMessage, 'error');
          }
        }
      },
      error: function(xhr, status, error) {
        console.error('Error loading text content:', error);
        const errorMessage = '加载内容失败：' + error;
        if (typeof showToast === 'function') {
          showToast(errorMessage, 'error');
        } else {
          showSimpleToast(errorMessage, 'error');
        }
      },
      complete: function() {
        // Hide loading indicator
        $('.loading-container').addClass('hidden');
      }
    });
  }
  
  // 展开/收起按钮
  $('#toc-list').on('click', '[data-action="toggle"]', function(event) {
    event.preventDefault();
    event.stopPropagation();
    const node = this.closest('.toc-node');
    toggleNode(node);
  });

  // 点击文件夹图标也可展开/收起
  $('#toc-list').on('click', '.toc-item i.fa-folder-open', function(event) {
    const node = this.closest('.toc-node');
    if (node && node.dataset.hasChildren === 'true') {
      event.preventDefault();
      event.stopPropagation();
      toggleNode(node);
    }
  });

  // Handle checkbox changes
  $('.toc-container').on('change', '.toc-checkbox', function() {
    const href = $(this).data('toc-href');
    const node = this.closest('.toc-node');
    
    if ($(this).is(':checked')) {
      selectedTocItems.add(href);
      if (node && node.dataset.hasChildren === 'true') {
        expandNode(node);
      }
    } else {
      selectedTocItems.delete(href);
    }
    
    updateSelectionUI();
  });
  
  // Handle TOC link clicks (single selection for backward compatibility)
  $('.toc-container').on('click', '.toc-link', function(e) {
    e.preventDefault();
    
    const href = $(this).data('toc-href');
    const node = this.closest('.toc-node');

    if (node) {
      let ancestor = node;
      while (ancestor) {
        expandNode(ancestor);
        ancestor = ancestor.parentElement ? ancestor.parentElement.closest('.toc-node') : null;
      }
    }
    
    // Clear previous selections and select only this item
    selectedTocItems.clear();
    selectedTocItems.add(href);
    
    updateSelectionUI();
    loadSelectedTocItems();
  });
  
  // Handle select all button
  $('#select-all-btn').on('click', function(e) {
    e.preventDefault();
    selectedTocItems.clear();
    $('.toc-checkbox').each(function() {
      selectedTocItems.add($(this).data('toc-href'));
    });
    updateSelectionUI();
  });
  
  // Handle clear selection button
  $('#clear-selection-btn').on('click', function(e) {
    e.preventDefault();
    selectedTocItems.clear();
    updateSelectionUI();
  });
  
  // Handle load selected button
  $('#load-selected-btn').on('click', function(e) {
    e.preventDefault();
    loadSelectedTocItems();
  });
  
  // 显示OCR结果信息
  function showOCRResultInfo(response) {
    if (response.ocr_results && response.ocr_results.length > 0) {
      const cachedCount = response.cached_count || 0;
      const totalCount = response.ocr_results.length;
      const errorCount = response.ocr_results.filter(r => r.error).length;
      
      let message = `OCR识别完成：处理${totalCount}页`;
      if (cachedCount > 0) {
        message += `，其中${cachedCount}页使用缓存`;
      }
      if (errorCount > 0) {
        message += `，${errorCount}页识别失败`;
      }
      if (response.auto_ocr) {
        message += ` (自动OCR)`;
      }
      
      // 显示临时提示
      if (typeof showToast === 'function') {
        showToast(message, 'info', 3000);
      } else {
        console.log(message);
        // 创建简单的临时提示
        showSimpleToast(message, 'info');
      }
    }
  }

  // 简单的Toast提示（如果全局showToast不可用）
  function showSimpleToast(message, type = 'info') {
    // 移除已存在的toast
    $('.simple-toast').remove();
    
    // 根据类型选择图标
    let icon;
    switch(type) {
      case 'error':
        icon = `
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        `;
        break;
      case 'success':
        icon = `
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        `;
        break;
      case 'warning':
        icon = `
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v3.75m9-.75a9 9 0 11-18 0 9 9 0 0118 0zm-9 3.75h.008v.008H12v-.008z" />
          </svg>
        `;
        break;
      default: // info
        icon = `
          <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
          </svg>
        `;
    }
    
    const toast = $(`
      <div class="simple-toast fixed top-4 right-4 z-50 max-w-sm">
        <div class="alert alert-${type} shadow-lg transform transition-all duration-300 ease-in-out opacity-0">
          <div>
            ${icon}
            <span>${message}</span>
          </div>
        </div>
      </div>
    `);
    
    $('body').append(toast);
    
    // 显示动画
    setTimeout(() => {
      toast.find('.alert').removeClass('opacity-0').addClass('opacity-100');
    }, 10);
    
    // 自动隐藏时间根据类型调整
    const hideDelay = type === 'error' ? 5000 : 3000; // 错误消息显示更久
    setTimeout(() => {
      toast.find('.alert').removeClass('opacity-100').addClass('opacity-0');
      setTimeout(() => {
        toast.remove();
      }, 300);
    }, hideDelay);
  }
  
  // Auto-load the first TOC item (for backward compatibility)
  if ($('.toc-link').length > 0) {
    $('.toc-link:first').trigger('click');
  }
  
  // Scroll to active item on initial load
  setTimeout(scrollActiveIntoView, 300);
});
</script>
